require "kemal"
require "jwt"

struct DppmRestApi::Actions::RelativeRoute
  @@access_filter : Proc(HTTP::Server::Context, Access, Config::User) = ->default_access_filter(HTTP::Server::Context, Access)
  @@algorithm = JWT::Algorithm::HS256
  @@secret_key : String = Random::Secure.base64(32)

  getter root_path : String

  def initialize(@root_path : String)
  end

  def self.new(root_path : String, &) : RelativeRoute
    route = new(root_path)
    with route yield
    route
  end

  {% for method, right in {get: "Read", post: "Create", put: "Update", delete: "Delete", options: "Read"} %}
    # Perform a relative {{method.id}} from the `root_path`.
    # That is, these routes are namespaced underneath a route generated by the name
    # of the type this method is included on. If a route is defined with
    # ```
    # {{method.id}}("/some/:path") { ... }
    # ```
    # Then the actual path a request should be made on is
    # `"@root_path/some/path-param"`
    def relative_{{method.id}}(route : String? = nil, &block : HTTP::Server::Context, Config::User ->)
      {{method.id}} root_path + route.to_s do |context|
        #namespace = context.params.query["namespace"]? || DPPM::Prefix.default_group
        user = @@access_filter.call context, Access::{{right.id}}
        block.call context, user
      rescue ex : Actions::Exception
        raise ex
      rescue ex
        # Catch non-HTTPStatusError exceptions, and throw an InternalServerError
        # with the original error as the cause.
        raise InternalServerError.new context, cause: ex
      end
    end
  {% end %}

  def self.encode(user_info)
    JWT.encode(payload: user_info.to_h, key: @@secret_key, algorithm: @@algorithm)
  end

  # Returns the user if authorized.
  private def self.default_access_filter(context : HTTP::Server::Context, permission : Access) : Config::User
    if token = (context.request.headers["X-Token"]? || context.params.query["auth"]?)
      payload, _ = JWT.decode token: token, key: @@secret_key, algorithm: @@algorithm
      user_hash = JWTCompatibleHash.new payload.size
      payload.as_h.each { |k, v| user_hash[k] = v.as_s? || v.as_i? || v.as_bool? }

      if received_user = Config::User.from_h hash: user_hash
        return received_user if DppmRestApi.permissions_config.group_view(received_user).find_group? do |group|
                                  group.can_access?(
                                    context.request.path,
                                    context.request.query_params,
                                    permission
                                  )
                                end
      end
    end
    raise Unauthorized.new context
  end
end
