struct DppmRestApi::Actions::RelativeRoute
  getter root_path : String

  def initialize(@root_path : String)
  end

  def self.new(root_path : String, &) : RelativeRoute
    route = new(root_path)
    with route yield
    route
  end

  {% for method, right in {get: :read, post: :create, put: :update, delete: :delete, options: :read} %}
    # Perform a relative {{method.id}} from the `root_path`.
    # That is, these routes are namespaced underneath a route generated by the name
    # of the type this method is included on. If a route is defined with
    # ```
    # {{method.id}}("/some/:path") { ... }
    # ```
    # Then the actual path a request should be made on is
    # `"@root_path/some/path-param"`
    def relative_{{method.id}}(route : String? = nil, &block : HTTP::Server::Context, Config::User ->)
      {{method.id}} root_path + route.to_s do |context|
        #namespace = context.params.query["namespace"]? || DPPM::Prefix.default_group
        user = Actions.authorized_user context, {{right.symbolize.id}}
        block.call context, user
      rescue ex : Actions::Exception
        raise ex
      rescue ex
        # Catch non-HTTPStatusError exceptions, and throw an InternalServerError
        # with the original error as the cause.
        raise InternalServerError.new context, cause: ex
      end
    end
  {% end %}

  # Build JSON directly to the HTTP response IO. This yields inside of an
  # object labelled "data", like
  # ```
  # {"data": {"whatever": "you build"}}
  # ```
  # Since it's in an object, one needs to use `JSON::Builder#field` at the
  # top-level within the block.
  #
  # NOTE: One must also ensure that the block does not raise an exception --
  # this would result in invalid JSON being output as the response body. For
  # example...
  # ```
  # build_json do
  #   raise InternalServerError.new "Oh no!"
  # end
  # ```
  # ...would result in the following response body...
  # ```
  # {"data":{"errors": [{"type": "InternalServerError", "status_code": 500, "message": "oh no!"}]}
  # ```
  # ...which is not valid JSON due to the unclosed object written at the beginning.
  def build_json(response : IO, & : JSON::Builder ->)
    JSON.build response do |json|
      json.object do
        json.field("data") { json.object { yield json } }
      end
    end
  end

  # Get a prefix from a context, which has a source name.
  def get_prefix_with_source_name(context : HTTP::Server::Context) : DPPM::Prefix
    DPPM::Prefix.new(
      path: Actions.prefix.path.to_s,
      group: Actions.prefix.group,
      source_name: URI.decode(context.params.url["source_name"]),
      source_path: Actions.prefix.source_path
    ).tap &.ensure_pkg_dir
  end
end
